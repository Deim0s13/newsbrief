name: Project Board Automation

on:
  workflow_dispatch:
  issues:
    types: [opened, labeled, reopened, closed, assigned]
  pull_request:
    types: [opened, ready_for_review, closed]

permissions:
  contents: read
  issues: write
  pull-requests: write
  # projects: write  # Not available in GITHUB_TOKEN

env:
  PROJECT_NUMBER: "7"  # NewsBrief Roadmap project

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Add to Project + Set Fields
        uses: actions/github-script@v7
        continue-on-error: true  # Don't fail CI/CD if project sync fails
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const gql = (q,v) => github.graphql(q, v)
              const login = context.repo.owner
              const number = parseInt(process.env.PROJECT_NUMBER, 10)

              console.log(`üîç Looking for project #${number} under user: ${login}`)

              // 1) Resolve project id - try user account only (not organization)
              const proj = await gql(`
                query($login:String!,$num:Int!){
                  user(login:$login){ projectV2(number:$num){ id } }
                }`, { login, num: number })
              
              const projectId = proj.user?.projectV2?.id
              if (!projectId) {
                console.log(`‚ùå Project #${number} not found under user ${login}`)
                console.log('Available projects might require different permissions or number')
                return  // Don't fail the workflow
              }

              console.log(`‚úÖ Found project: ${projectId}`)

              // 2) Identify triggering content (Issue or PR)
              const isIssue = context.eventName === 'issues'
              const payload = isIssue ? context.payload.issue : context.payload.pull_request
              const contentId = payload.node_id

              console.log(`üìã Processing ${isIssue ? 'issue' : 'PR'}: ${payload.title}`)

              // 3) Ensure the item is in the project
              let itemId
              try {
                const add = await gql(`
                  mutation($projectId:ID!,$contentId:ID!){
                    addProjectV2ItemById(input:{projectId:$projectId,contentId:$contentId}){ item { id } }
                  }`, { projectId, contentId })
                itemId = add.addProjectV2ItemById.item.id
                console.log(`‚úÖ Added item to project: ${itemId}`)
              } catch (e) {
                console.log(`‚ÑπÔ∏è  Item might already be in project, searching...`)
                
                const items = await gql(`
                  query($projectId:ID!){
                    node(id:$projectId){
                      ... on ProjectV2 {
                        items(first:100){ nodes { id content { ... on Issue { id } ... on PullRequest { id } } } }
                      }
                    }
                  }`, { projectId })
                itemId = items.node.items.nodes.find(n => n.content?.id === contentId)?.id
                
                if (!itemId) { 
                  console.log("‚ùå Item not found in project and cannot add")
                  return  // Don't fail the workflow
                }
                console.log(`‚úÖ Found existing item: ${itemId}`)
              }

              // 4) Fetch fields (Status, Epic) and auto-detect Status options
              const f = await gql(`
                query($projectId:ID!){
                  node(id:$projectId){
                    ... on ProjectV2 {
                      fields(first:50){
                        nodes {
                          ... on ProjectV2FieldCommon { id name }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                        }
                      }
                    }
                  }
                }`, { projectId })
                
              const fields = f.node.fields.nodes
              const findField = n => fields.find(fl => fl.name === n)
              const statusField = findField("Status")
              const epicField   = findField("Epic")

              console.log(`üìä Available fields: ${fields.map(f => f.name).join(', ')}`)

              if (!statusField) { 
                console.log("‚ÑπÔ∏è  No Status field found; exiting gracefully")
                return 
              }
              
              const statusOpts = statusField.options || []
              console.log(`üìù Status options: ${statusOpts.map(o => o.name).join(', ')}`)
              
              const firstOpt   = statusOpts[0]
              const findOpt = (...candidates) => {
                const exact = n => statusOpts.find(o => o.name.toLowerCase() === n.toLowerCase())
                for (const n of candidates) { const m = exact(n); if (m) return m }
                const rx = new RegExp(candidates.join("|"), "i")
                return statusOpts.find(o => rx.test(o.name))
              }
              
              const todoOpt = firstOpt || findOpt("Todo","To do","Not started","Backlog")
              const wipOpt  = findOpt("In Progress","In progress","Doing","WIP","Started") || todoOpt
              const doneOpt = findOpt("Done","Complete","Completed","Closed","Resolved") || statusOpts[statusOpts.length-1] || todoOpt

              async function setSingleSelect(field, opt, reason) {
                if (!field || !opt) return
                console.log(`üîÑ Setting ${field.name} to "${opt.name}" (${reason})`)
                await gql(`
                  mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$opt:String!){
                    updateProjectV2ItemFieldValue(input:{
                      projectId:$projectId,itemId:$itemId,fieldId:$fieldId,
                      value:{ singleSelectOptionId:$opt }
                    }){ projectV2Item { id } }
                  }`, { projectId, itemId, fieldId: field.id, opt: opt.id })
                console.log(`‚úÖ Updated ${field.name}`)
              }
              
              const setStatus = (opt, reason) => setSingleSelect(statusField, opt, reason)

              // 5) Epic mapping from labels (issues only)
              if (isIssue) {
                const labels = (payload.labels || []).map(l => l.name)
                const epicLabel = labels.find(l => l.startsWith("epic:"))
                const epicName  = epicLabel ? epicLabel.replace(/^epic:/,'').trim() : null
                
                if (epicName && epicField) {
                  const epicOpt = (epicField.options || []).find(o => o.name === epicName)
                  if (epicOpt) {
                    await setSingleSelect(epicField, epicOpt, `epic label: ${epicLabel}`)
                  } else {
                    console.log(`‚ö†Ô∏è  Epic "${epicName}" not found in project field options`)
                  }
                }
              }

              // 6) Status rules
              const action = context.payload.action
              console.log(`‚ö° Processing action: ${action}`)

              // New / Reopened -> Todo
              if ((isIssue && (action === 'opened' || action === 'reopened')) ||
                  (!isIssue && action === 'opened')) {
                await setStatus(todoOpt, `${action} ${isIssue ? 'issue' : 'PR'}`)
              }

              // Assigned or labeled "in-progress" -> In Progress
              if ((isIssue && action === 'assigned') ||
                  (isIssue && action === 'labeled' && context.payload.label?.name === 'in-progress') ||
                  (!isIssue && action === 'ready_for_review')) {
                await setStatus(wipOpt, `${action} ${isIssue ? 'issue' : 'PR'}`)
              }

              // Closed or PR merged -> Done
              if ((isIssue && action === 'closed') ||
                  (!isIssue && action === 'closed' && context.payload.pull_request.merged)) {
                await setStatus(doneOpt, `${action} ${isIssue ? 'issue' : 'PR'}`)
              }

              console.log(`‚úÖ Project automation completed successfully`)
              
            } catch (error) {
              console.error(`‚ùå Project automation failed: ${error.message}`)
              console.error(`Stack trace: ${error.stack}`)
              // Don't throw - let the workflow continue
              console.log(`‚ÑπÔ∏è  Continuing workflow despite project sync failure`)
            }
